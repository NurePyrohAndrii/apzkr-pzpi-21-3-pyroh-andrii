Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА

з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для контролю за виноградниками

Студент гр. ПЗПІ-21-3 	__________________ Пирог А. В.
(підпис)

Керівник роботи 		__________________ доц. Лещинська І.О.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________

Комісія: 				__________________ доц. Лещинська І.О.
(підпис)
__________________ доц. Лещинський В.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків
2024 р.
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук                           Кафедра програмної інженерії     
Спеціальність 121 – Інженерія програмного забезпечення                                       
Курс                   3                   Семестр                                  6                                       
Навчальна дисципліна Архітектура програмного забезпечення                              

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                             Пирогу Андрію Вячеславовичу                                         
1. Тема роботи: «Програмна система для контролю за виноградниками»
2. Термін узгодження завдання курсової роботи «   19   »    лютого     2024 р.
3. Термін здачі студентом закінченої роботи «   15   »    червня     2024 р.
4. Вихідні дані до проекту (роботи): оригінальність проекту, актуальність теми проекту, масштабованість розроблюваної системи, орієнтованість системи на масового користувача, українська та англійська локалізація, захист персональних даних користувачів, вбудовані програмні засоби адміністрування системи та створення резервних копій бази даних, передбачення монетизації розробленого проекту_________________________________________________                                                                        
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, концепція та рамки проекту, проектування та реалізація серверної частини, інтернету речей та веб-клієнту, висновки, перелік посилань, додатки                                                     
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
Deployment Diagram, Use Case Diagram, ER-модель даних, Component Diagram, Package Diagram, Interaction Overview Diagram, Activity Diagram                            
КАЛЕНДАРНИЙ ПЛАН


№	Назва етапів курсової роботи	Термін виконання
етапів роботи	Примітка
1	Функціональна специфікація
програмного проекту	26.02.2024	виконано
2	Проектування програмного
проекту	04.03.2024	виконано
3	Кодування програмного проекту	20.05.2024	виконано
4	Оформлення пояснювальної
записки	05.06.2024	виконано
5	Захист курсової роботи	10.06.2024	виконано


Дата видачі завдання «   19   »       лютого       2024 р.

Керівник 					______________ доц. Лещинська І.О.
(підпис)

Завдання прийняв до виконання	
ст.гр. ПЗПІІ-21-3					      _____________ Пирог А. В.
(підпис)



РЕФЕРАТ

Пояснювальна записка до курсової роботи: 85 с., 10 рис., 3 табл., 3 додатки, 5 джерел.
ВИНОГРАДНИК, КОНТРОЛЬ, УПРАВЛІННЯ РЕСУРСАМИ, ІНТЕРНЕТ РЕЧЕЙ, АВТОМАТИЗАЦІЯ, ЗАХИСТ ДАНИХ, ЛОКАЛІЗАЦІЯ, КЛІЄНТСЬКИЙ ЗАСТОСУНОК, ІНТЕГРАЦІЯ, АДМІНІСТРУВАННЯ, МОНІТОРИНГ.
Об’єктом дослідження цієї роботи є виноградарство та управління виноградниками за допомогою сучасних технологій. Виноградарство є важливим аспектом аграрної галузі [1], що вимагає ретельного моніторингу та управління. Завдяки впровадженню інформаційних технологій можна значно підвищити ефективність процесів, забезпечуючи високу якість врожаю та оптимізацію ресурсів.
Метою роботи є розробка програмної системи для автоматизованого управління виноградниками. Система включає засоби моніторингу стану лози та ґрунту, ефективного адміністрування й обліку винограднику та його структури, адміністрування користувачами та надійного захисту даних користувачіва та аналізу даних для прийняття рішень. 
Для розробки системи використано платформи Spring Boot, Angular, та IoT [2] технології на основі мікроконтролера ESP32. Серверна частина реалізована на Java з використанням PostgreSQL для збереження даних. Клієнтська частина створена за допомогою Angular, що забезпечує зручний інтерфейс користувача.
Результатом роботи є функціональна система, що дозволяє здійснювати повний цикл управління виноградником: від моніторингу стану рослин до ефективного адміністрування й обліку винограднику та його структури та аналізу зібраних даних. 
 
ЗМІСТ

ВСТУП	7
1 БІЗНЕС-ВИМОГИ	8
1.1 Передумови	8
1.2 Бізнес-можливості	8
1.3 Бізнес-цілі та критерії успіху	9
1.4 Потреби клієнтів та ринку	10
1.5 Бізнес-ризики	11
2 КОНЦЕПЦІЇ РІШЕННЯ	12
2.1 Окреслення концепції	12
2.2 Головна функціональність	12
2.3 Припущення та залежності	13
3 РАМКИ ТА ОБМЕЖЕННЯ	15
3.1 Рамки первинного випуску	15
3.2 Рамки наступних випусків	17
3.3 Обмеження та винятки	17
4 БІЗНЕС-КОНТЕКСТ	19
4.1 Профілі зацікавлених сторін	19
4.2 Пріоритети проєкту	19
4.3 Робоче середовище	20
5 СЕРВЕРНА ЧАСТИНА	22
5.1 Опис інженерних рішень	22
5.2 Розробка діаграм	24
5.3 Специфікація REST	27
5.4 Опис частин програмного коду	31
6 ПРИСТРІЙ ІНТЕРНЕТУ РЕЧЕЙ	33
6.1 Опис інженерних рішень	33
6.2 Пояснення програмного коду	33
6.3 Розробка діаграм	37
7 ВЕБ-КЛІЄНТ	41
7.1 Опис інженерних рішень	41
7.2 Пояснення програмного коду	41
7.3 Розробка діаграм	48
ВИСНОВКИ	52
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	53
ДОДАТОК А	54
ДОДАТОК Б	55
ДОДАТОК В	77


ВСТУП

У сучасному світі аграрні технології відіграють все більш важливу роль у забезпеченні ефективного ведення сільського господарства. Особливе місце серед аграрних культур займає виноград, який потребує особливої уваги та ретельного догляду. Виноградарство вимагає постійного моніторингу стану лози, ґрунту та навколишнього середовища для забезпечення високої якості врожаю.
Інтеграція сучасних інформаційних технологій у процеси виноградарства відкриває нові можливості для оптимізації управління та підвищення ефективності. Автоматизація процесів, використання IoT пристроїв для моніторингу, аналіз даних для прийняття рішень на основі отриманої інформації дозволяють значно покращити ефективність управління виноградниками та догляду за лозами.
Метою даної курсової роботи є розробка програмної системи для автоматизованого управління виноградниками. Ця система повинна включати засоби для моніторингу стану виноградної лози, ефективного адміністрування й обліку винограднику, а також аналізу даних для оптимізації процесів вирощування винограду. Використання такої системи сприятиме підвищенню ефективності роботи виноградарів, покращенню якості продукції та зниженню витрат на обробіток.
У ході роботи буде проведено аналіз існуючих рішень на ринку, визначено основні вимоги до програмної системи, розроблено архітектуру та реалізовано відповідну програмну систему. Також буде здійснено тестування розробленої системи для перевірки її функціональності та ефективності. 
Таким чином, дана курсова робота має на меті внести вагомий внесок у розвиток інформаційних технологій у сфері аграрного господарства та сприяти підвищенню конкурентоспроможності виноградарів на ринку.  
1 БІЗНЕС-ВИМОГИ
1.1 Передумови

Управління виноградниками є критично важливим аспектом виноробної галузі, що вимагає прискіпливої уваги до деталей та розуміння різних факторів, які впливають на якість та врожайність винограду. Воно охоплює діяльність від обробітку ґрунту та боротьби зі шкідниками до зрошення та термінів збору врожаю, і все це спрямовано на виробництво винограду найвищої якості. 
Виноградарі стикаються з численними проблемами, включаючи, наслідки зміни клімату, боротьбу зі шкідниками та хворобами, ефективність зрошення та витрати на робочу силу.
Інтеграція технологій у сільське господарство революціонізувала практику ведення сільського господарства, пропонуючи рішення для багатьох проблем, з якими стикаються фермери та виробники. Зокрема, програмні системи відіграли важливу роль у підвищенні ефективності, забезпеченні точного землеробства та наданні інформації на основі даних для кращого прийняття рішень.
В управлінні та контролі виноградниками існує особлива потреба в програмній системі, яка може запропонувати моніторинг росту лози, стану ґрунту та погодних даних в режимі реального часу, автоматизувати зрошення та боротьбу зі шкідниками, а також надавати аналітику для оптимізації врожайності.
Основною метою програмної системи для контроля за виноградниками є вирішення цих проблем шляхом надання рішення, яке підвищить ефективність, знизить витрати і підвисить якість виробництва винограду за рахунок прийняття рішень на основі зібраних даних і автоматизації.


1.2 Бізнес-можливості

На ринку вже існують деякі аналоги програм, призначених для управління виноградниками:
1) Fishbowl: спеціалізується на інвентаризації, управлінні замовленнями та виставленні рахунків, обслуговуючи в першу чергу логістичні та бізнес-аспекти виробництва вина.
2) AMS: це система управління виноградниками яка відповідає за облік, продаж та багато інших послуг пов’язані з автоматизацією роботи цього бізнесу. Забезпечує більш цілеспрямований підхід до управління виноградниками за допомогою бухгалтерського обліку.
Відмінною рисою нашої системи буде саме робота з виноградними кущами, їх облік, стеження, контроль та сповіщення про необхідність догляду за ними.
Програмний продукт орієнтований на малі та середні виноградники, які є дуже поширеним видом діяльності по всьому світу. «Acumen research and consulting» запевняє, що у 2021 році обсяг світового ринку вина склав 489,3 млрд доларів США і, за оцінками, досягне 825,5 млрд доларів США до 2030 року, зростаючи на 6,1% в середньорічному обчисленні в період з 2022 по 2030 рік.
Як модель монетизації слід впровадити багаторівневу модель підписки, що дозволить виноградникам будь-якого розміру обрати рівень обслуговування, який найкраще відповідає їхнім потребам. Ця модель забезпечить стабільний потік доходів, одночасно надаючи користувачам гнучкість і масштабованість.




1.3 Бізнес-цілі та критерії успіху

Бізнес-цілі (BO - Business Objectives):
BO-1: Підвищити операційну ефективність управління виноградниками на 40% за рахунок автоматизації зрошення, боротьби зі шкідниками, моніторингу росту виноградної лози та стану ґрунту.
BO-2: Знизити витрати на утримання виноградників на 30% щорічно за рахунок оптимізації використання ресурсів та мінімізації відходів завдяки аналітиці на основі даних та методам точного землеробства.
BO-3: Підвищити якість врожаю винограду на 20% протягом першого року впровадження системи відповідно до галузевих стандартів якості.
Критерії успіху (SC - Success Criteria):
SC-1: Створити базу користувачів з 500 малих та середніх виноградників протягом перших двох років після запуску.
SC-2: Досягти рівня задоволеності клієнтів понад 85% на основі відгуків користувачів та показників утримання клієнтів протягом першого року роботи.

1.4 Потреби клієнтів та ринку

Потреби клієнтів (СN – Customer Needs):
CN-1: Моніторинг в режимі реального часу за ростом виноградної лози, станом ґрунту та погодними даними для прийняття рішень та оптимізації роботи виноградників.
CN-2: Автоматизовані рішення для зрошення та боротьби зі шкідниками, які зменшують потребу в ручній праці та підвищують ефективність управління ресурсами.
Потреби ринку (MN – Market Needs):
MN-1: Масштабовані моделі підписки, які дозволяють виноградникам різного розміру обирати та оплачувати лише ті функції, які їм потрібні, забезпечуючи гнучкість та економічну ефективність.
MN-2: Зручні інтерфейси та служби підтримки, які полегшують впровадження та ефективне використання програмного забезпечення менеджерами виноградників з різним рівнем технологічної підготовки.

1.5 Бізнес-ризики

BR-1: Опір впровадженню технологій серед цільових клієнтів через брак технічних навичок або несприйняття змін. 
Щоб уникнути цього слід впроваджувати комплексні програми навчання користувачів, інтуїтивно зрозумілий UI/UX-дизайн та чуйну підтримку клієнтів, щоб полегшити перехід та продемонструвати відчутні переваги.
BR-2: Залежність від точних і своєчасних даних, яка може бути порушена через несправності датчиків або помилки в обробці даних. 
Щоб уникнути цього слід забезпечити надійність системи шляхом ретельного тестування, регулярного оновлення програмного забезпечення та створення надійного протоколу обслуговування клієнтів для усунення несправностей і надання технічної допомоги.



2 КОНЦЕПЦІЇ РІШЕННЯ
2.1 Окреслення концепції

		Програмна система для контроля за виноградниками призначена для людей, які доглядають за виноградниками. Чи це маленьке сімейне господарство, чи середнього розміру підприємство з командою фермерів-виноградарів, цей програмний продукт має на меті автоматизувати частину процесів догляду за виноградом, щоб зменшити вплив людського фактору до мінімуму. Цей інструмент також допоможе малому та середньому бізнесу з обліком та контролем кожного куща, що стане у нагоді для менеджменту свого господарства. 

2.2 Головна функціональність

МF-1: Безпечна реєстрація та авторизація користувачів;
MF-2: Створення та керування акаунтом свого господарства;
MF-3: Створення та керування блоками виноградників;
MF-4: Створення та керування групами кущів винограду;
MF-5: Створення та керування виноградними кущами, як і в межах відповідних блоків, так і в межах груп;
MF-6: Створення та керування пристроями для моніторингу виноградних кущів;
MF-7: Збір та збереження даних з пристроїв;
MF-8: Аналіз даних з пристроїв та формування агрометеорологічної статистики і звітів про стан виноградників;
MF-9: Створення та керування попередженнями про необхідність проведення догляду за виноградними кущами (полив, оприскування, катарування, обрізка, підгортання та розгортання ґрунту перед та після зими, збір винограду);
MF-10: Автоматична система попереджень на основі прогнозу погоди та аналізу данних з датчиків;
MF-11: Управління графіками та правилами зрошення виноградних кущів, включаючи можливість коригування на основі прогнозів погоди, потреб виноградників та рівня вологості ґрунту.
MF-12: Управління графіками та правилами внесення добрив та обробок кущів винограду;
MF-13: Адміністрування користувачами та аккаунтами господарств;
MF-14: Інтернаціоналізація та локалізація інтерфейсу (українська та англійська мови);
MF-15: Кластерний аналіз для ідентифікації схожих ділянок (користувач зможе оптимізувати підхід до обробітку кожної ділянки, зрошення, внесення добрив тощо, згідно з їхніми специфічними потребами);
MF-16: Аналіз тенденцій агрометеорологічних умов, за допомогою аналізу часових рядів, зокрема, методів регресійного аналізу.

2.3 Припущення та залежності

Припущення (AS - Assumption):
AS-1: Припущення щодо навичків користувачів - припускається, що користувачі будуть мати базові навички користування веб-додатками та мобільними додатками.
AS-2: Доступ до Інтернету - припускається, що користувачі матимуть доступ до Інтернету для взаємодії з платформою.
AS-3: Сумісність з пристроями - припускається, що програмний продукт буде сумісним з різними типами пристроїв, включаючи комп'ютери, смартфони та планшети.
AS-4: Господарства будуть готові вносити необхідні дані.
AS-5: Дані, отримані від IoT-сенсорів, будуть надходити безперервно та з надійністю для аналізу.
AS-6: Доступність даних - припускається, що дані з пристроїв мониторингу будуть доступні та відповідатимуть вимогам для аналізу та обробки.
Залежності (DP - Dependencie):
DP-1: Інтеграція з платіжними системами - для обробки платежів та транзакцій при монетизації платформи, буде потрібна інтеграція з платіжними системами.
DP-2: Розвиток мобільних додатків - залежність від розробки мобільних додатків для підтримки мобільних пристроїв користувачів.
DP-3: Оновлення даних - потреба у регулярному оновленні даних та актуалізації ситуації на винограднику.
DP-4: Підтримка браузерів та операційних систем - залежність від технічної сумісності та підтримки різних браузерів та операційних систем для коректної роботи веб-інтерфейсу та мобільних додатків.
DP-6: Залежність від інфраструктури IoT – якщо використовуються IoT-сенсори для збору додаткових даних, буде залежність від наявності та надійності інфраструктури IoT.



3 РАМКИ ТА ОБМЕЖЕННЯ
3.1	 Рамки первинного випуску

Опишемо загальну функціональність першої версії системи.
Серверний застосунок буде розроблений для обробки та збереження даних системи, а саме:
-	Реєстрація й авторизація користувачів з використанням jwt [3] токенів;
-	Створення та керування акаунтом свого господарства: створювати та видалити акаунт, редагувати його інформацію,  видалення акаунту, додавання користувачів до господарства;
- Створення та керування блоками виноградників: створювати блок, редагувати дані про нього, видалити його, додавання, редагування та видалення виноградних кущів та груп кущів в рамках блоку;
- Створення та керування групами кущів винограду: створювати групу, редагувати дані про неї, видалити її, додавання, редагування та видалення виноградних кущів в рамках групи;
- Створення та керування виноградними кущами: створювати кущ, редагувати дані про нього, видалити його.
- Створення та керування пристроями для моніторингу виноградних кущів: створювати пристрій, редагувати інформацію про нього, видалити його, підв’язати пристрій до відповідного куща, групи, чи блоку;
- Збір та збереження даних з пристроїв;
- Аналіз даних з пристроїв та формування статистики: аналіз даних з пристроїв інтернету речей та формування агрометеорологічної статистики  і звітів про стан виноградників в рамках блоків та груп;;
- Створення та керування попередженнями про необхідність відповідних дій або догляду за виноградними кущами: створювати сценарій для спрацювання попередження, редагувати та видаляти цей сценарій;
- 	Локалізація українською, англійською мовами та інтернаціоналізація;
     -	Адміністрування користувачами та господарствами, а саме їх пошук, блокування, зняття блокування та видалення;
Веб-застосунок буде розроблений для візуалізації та взаємодії з функціональністю системи:
-	Візуалізація та зручність користування можливостями керування акаунтом господарства; 
-	Візуалізація та зручність користування інструментами керування блоками та групами виноградників;
-	Візуалізація та зручність користування можливостями керування  інформацією про виноградні кущі;
-	Візуалізація та зручність користування інструментами керування пристроями для моніторингу виноградних кущів;
- Візуалізація та зручність користування інструментами керування попередженнями;
-	Візуалізація та зручність перегляду аналізу та статистики, сформованої на основі даних з пристроїв; 
-	Візуалізація та зручність адміністрування користувачами та акаунтами їх господарств.
Мобільний застосунок буде призначений для:
-	Відображення сповіщень про попередження;
- 	Відображення даних з пристроїв у режимі реального часу, асоційованих до відповідних кущів, груп та блоків;
-	Інтерфейс для зручного налаштування повідомлень попереджень.
IoT пристрої будуть використовуватися для збору та обробки даних про стан винограднику. Будуть відслідковуватись такі показника як:
-	Кількість освітлення;
-	Вологість ґрунту;
-	Температура та вологість повітря.

3.2 Рамки наступних випусків

У майбутніх випусках програмного продукту планується наступне розширення функціональності:
-	Незалежна система попереджень на основі прогнозу погоди;
-	Управління графіками та правилами зрошення виноградних кущів, включаючи можливість коригування на основі прогнозів погоди, потреб виноградників та рівня вологості ґрунту;
- 	Кластерний аналіз для ідентифікації схожих ділянок;
-	Аналіз тенденцій агрометеорологічних умов, за допомогою аналізу часових рядів, зокрема, методів регресійного аналізу.
	Передбачено додавання інтерфейсів у веб застосунку для:
-	Відображення попереджень та даних, на основі яких ці попередження спрацьовують;
- Візуалізація та зручність користування інструментами керування графіками та правилами зрошення виноградних кущів;
- Візуалізація та зручність користування інструментами керування графіками та правилами внесення добрив та обробок кущів винограду.
Розширення збору та обробки даних на IoT пристрої. Зокрема передбачено додавання відслідковування наступних показників:
-	Просторове положення сектору посадки;
-	Висота кущів;
-	Швидкість та температуру вітру.

3.3 Обмеження та винятки

Обмеження (L - Limitation):
L-1: Технічні обмеження - програмного продукту може залежати від наявності високошвидкісного інтернет-з'єднання та сумісного обладнання.
L-2: Конфіденційність даних - збір і аналіз даних користувачів та пристроїв повинен здійснюватися з дотриманням нормативів конфіденційності та дотриманням всіх законодавчих обмежень щодо збору та обробки особистої інформації.
Винятки (E - Exclusions):
E-1: Світові закони - робота системи може обмежуватися законами та регуляціями різних країн, зокрема щодо збору, збереження і аналізу даних.
E-2: Апаратні обмеження - деякі функції можуть бути недоступні через обмеження апаратного забезпечення користувачів, наприклад, в разі відсутності певних сенсорів чи апаратних можливостей.


4 БІЗНЕС-КОНТЕКСТ
4.1 Профілі зацікавлених сторін

Таблиця 1 – Профілі зацікавлених сторін проекту
Зацікавлена сторона 	Головна зацікавленість 	Ставлення до продукту 	Обмеження 
Власники 	Максимізація прибутку, ефективність	Позитивне, інвестують у продукт	Бюджетні обмеження
Фермери-виноградарі	Зручність, ефективність, простота використання	Шукають технічні рішення для полегшення роботи	Технічні навички
Менеджери	Оптимізація робочих процесів, звітність	Зацікавлені в детальній аналітиці і звітах	Навички управління даними
ІТ-спеціалісти 	Інтеграція, налаштування, підтримка	Технічне зацікавлення у впровадженні	Технічні обмеження


4.2 Пріоритети проєкту

Таблиця 2 – Пріоритети проєкту
Область	Мета	Обмеження	Припустимий стан
Часовий графік	Випуск першої версії до 25.05.2024	Незаплановані проблеми та обставини	Готовність першої версії - 25.05.2024


Продовження таблиці 2
Функціональність	Повна реалізація головних функцій для задоволення потреб користувачів	Обмежений час на розробку	80% функцій будуть розроблені у першій версії
Якість	Стабільність та відсутність помилок під час роботи системи	Обмежений час на тестування	Система може містити несерйозні помилки, які не завадять роботі із системою
Команда	Один розробник, який поступово розробить продукт	Одноосібна розробка	Розробник повинен мати достатній рівень знань та доступ до навчальних ресурсів
Бюджет	Мінімізація витрат	Збільшення цін на оренду віддалених серверів та доменних імен	Витрати не повинні перевищувати 10000$

4.3 Робоче середовище

Для розробки серверної частини системи буде використовуватися Spring Boot 3.2.3, мова Java 17 версії та InteliJ IDEA Ultimate 2023.2.5 у якості середи розробки.
Для зберігання та керування даними буде використана система управління базами даних PostgreSQL 14.7, бібліотеки Liquibase та Hibernate.
Для контейнеризації та розгортання сервісів будемо використовувати Docker 24.0 версії, який використовує WSL 2. 
Для розробки веб-клієнту буде використовуватися фреймворк Angular 16 для розробки на TypeScript, який забезпечить надійну структуру проекту для розробників. Також передбачене використання середовища розробки JetBrains Web Storm 2023.2.5.
IoT пристрій буде розроблено за допомогою cимулятора WOKWI на платформі espressif32 з використанням плати ESP32, фреймворку Arduino та мови C++.
Ця технологічна інфраструктура забезпечує високу продуктивність та надійність системи. Однак важливо враховувати наступні фактори:
-	Географічний розподіл користувачів: Користувачі можуть бути
розташовані у різних географічних регіонах.
-	Часові пояси: Зважаючи на різницю в часових поясах, необхідно
забезпечити зручний доступ до системи для користувачів із різних часових поясів.
-	Обробка та передача даних: Дані можуть генеруватися в різних
місцях та потребують передачі до центральної системи.
-	Надійність та доступність: Постійний доступ до системи може бути
вирішальним для бізнес-процесів користувачів.
-	Захист даних: Система повинна забезпечити контроль доступу та
захист особистих даних користувачів.
-	Моніторинг та управління продуктивністю: Слід слідкувати за
продуктивністю системи та мати можливість вчасно виявляти та усувати недоліки.
 
5 СЕРВЕРНА ЧАСТИНА
5.1 Опис інженерних рішень

Серверна частина додатку розроблена на мові програмування Java за допомогою фреймворку Spring Boot фреймворку версії 3.2. Як СУБД було обрано PostgreSQL 14 версії. Для зв’язку серверного застосунку з базою даних було використано Spring Data JPA [4], який є частиною фреймворку для роботи з даними Spring Data. Для валідації вхідних даних було використано Java Bean Validation API, який є частиною Spring Framework. Для впровадження захисту даних користувачів використано Spring Security. Версії усіх перечислених компонентів наслідуються від версії Spring Boot фреймворку.
Сам серверний застосунок представляє з себе монолітний за архітектурою проект. Структура проекту відповідає модульному підходу, який, як правило, вважається гарною практикою для підтримки та масштабування монолітних проетів. Проект організовано у пакети на основі компонентів системи (рис. 5.1), таких як common, controller, domain, security, user. Кожен з цих пакетів має в собі відповідні підпакети, які створені для розподілення та групування класів відповідних певному слою програми або компоненту системи, що допомагає тримати споріднені класи разом, що полегшує їх пошук і підтримку.
 
Рисунок 5.1 – Пакети проекту
	
Кожен пакет містить в собі відповідні підпакети (рис. 5.2).

  
Рисунок 5.2 – Файли у пакеті domain/vineyard

Файли типу Controller відповідають за обробку запитів на певні URL-адреси, обробку даних з форм та взаємодію з відповідними сервісами для виконання запиту користувача. Сервіси інкапсулюють бізнес-логіку додатку та обробку даних. Репозиторії відповідають за управління збереженням та вилученням даних із бази даних. Request та Response є DTO класами, які призначені для зберігання даних, надісланих клієнтом та для структурування даних відповіді серверу відповідно. Mapper класи керують перетворенням даних, він конвертує дані з сутностей (що використовуються базою даних) в DTO.

5.2 Розробка діаграм

Було розроблено діаграму розгортання для додатку (рис. 5.3). Програма розгортається влаштованим Apache Tomcat контейнером сервлетів всередині серверу, а база даних у власному сервері. Фронтенд розгортається на nginx сервері, а андроїд застосунок розгортається за допомогою Android Runtime (ART). Усі компоненти взаємодіють за допомогою TCP протоколу на транспортному рівні, а на прикладному рівні за допомогою HTTP.

 
Рисунок 5.3 – Діаграма розгортання додатку
	Було розроблено ER-діаграму для реляційної бази даних проекту (рис. 5.4).

  
Рисунок 5.4 – ER-діаграма бази даних

	На діаграмі зображено сутності Користувач, Виноградник, Роль, Блок, Група, Лоза, Пристрій, Дані пристрою, Адреса та зв’язки між ними. Загалом присутні 5 зв’язків один-до-багатьох (Виноградник – Група, Виноградник – Блок, Блок – Лоза, Користувач – Виноградник, Пристрій – Дані пристрою), 2 зв’язки один-до-одного (Лоза – Пристрій, Виноградник – Адреса) та 2 зв’язоки багато-до-багатьох (Користувач – Роль, Група - Лоза), що при створенні бази даних будуть реалізовані за допомогою проміжної таблиці та зв’язками один-до-багатьох.
	Для візуального представлення взаємодії між користувачами і системою була розроблена Use Case діаграма (рис. 5.5). У системі є 5 акторів: користувач, працівник, менеджер, директор та адміністратор. Директор винограднику має доступ до усіх функцій системи, окрім тих що пов'язані з загальним адмініструванням в додатку. Менеджер має повноважень меньше ніж директор, йому дозволено все, окрім найму, звільнення та перепризначення працівників на винограднику.  Працівнику винограднику дозволено керувати лозами та пристроями, але, на відміну від менеджера, не дозволено керувати блоками, групами. Користувач має можливість керувати власним профілем та створити власний виноградник. Адміністратор цповноважений видаляти та блокувати користувачів, а також створювати резервні копії бази даних.

  
Рисунок 5.5 – Use Case діаграма серверної частини
Для відображення структури та організації програмної системи було розроблено Package Diagram (рис. 5.6). Діаграма показує залежності поміж пакетами та як вони використовують одне одного для виконання своїх задач. На ній зображені 8 пакетів: Staff, Vineyard, Block, Group, Vine, Device, Security, User.

 
Рисунок  5.6 - Package Diagram серверної частини
	
5.3 Специфікація REST

Специфікація REST наведена нижче у таблиці 1, яка описує посилання, методи та призначення запитів.

Таблиця 1 – Специфікація REST API
Посилання	Метод	Опис методу
/api/v1/vineyards/{vineyardId}	GET	Отримання даних винограднику за ID
/api/v1/vineyards/{vineyardId}	PUT	Оновлення даних винограднику за ID
Продовження таблиці 1
/api/v1/vineyards/{vineyardId}	DELETE	Видалення винограднику за ID
/api/v1/vineyards/{vineyardId}/staff	GET	Отримання персоналу винограднику
/api/v1/vineyards/{vineyardId}/staff	PUT	Оновлення даних персоналу в винограднику
/api/v1/vineyards/{vineyardId}/staff	POST	Додавання персоналу в виноградник
/api/v1/vineyards/{vineyardId}/staff	DELETE	Звільнення персоналу з виноградника
/api/v1/vineyards/{vineyardId}/groups/{groupId}	GET	Отримання групи у винограднику
/api/v1/vineyards/{vineyardId}/groups/{groupId}	PUT	Оновлення групи у винограднику
/api/v1/vineyards/{vineyardId}/groups/{groupId}	DELETE	Видалення групи у винограднику
/api/v1/vineyards/{vineyardId}/blocks/{blockId}	GET	Отримання блоку у винограднику
/api/v1/vineyards/{vineyardId}/blocks/{blockId}	PUT	Оновлення блоку у винограднику
/api/v1/vineyards/{vineyardId}/blocks/{blockId}	DELETE	Видалення блоку у винограднику
/api/v1/vines/{vineId}/devices/{deviceId}	PUT	Оновлення деталей пристрою в винограднику
/api/v1/vines/{vineId}/devices/{deviceId}	DELETE	Видалення пристрою за ID
/api/v1/users	GET	Отримання всіх користувачів
/api/v1/users	PUT	Оновлення деталей користувача

Продовження таблиці 1
/api/v1/users	DELETE	Видалення користувача
/api/v1/users	PATCH	Зміна пароля автентифікованого користувача
/api/v1/blocks/{blockId}/vines/{vineId}	GET	Отримання деталей винограду в блоку
/api/v1/blocks/{blockId}/vines/{vineId}	PUT	Оновлення деталей винограду в блоку
/api/v1/blocks/{blockId}/vines/{vineId}	DELETE	Видалення винограду в блоку
/api/v1/vineyards	GET	Отримання списку всіх виноградників
/api/v1/vineyards	POST	Створення нового виноградника
/api/v1/vineyards/{vineyardId}/groups	GET	Отримання всіх груп у винограднику
/api/v1/vineyards/{vineyardId}/groups	POST	Створення групи у винограднику
/api/v1/vineyards/{vineyardId}/groups/{groupId}/vines	GET	Отримання всіх виноградів у групі
/api/v1/vineyards/{vineyardId}/groups/{groupId}/vines	POST	Додавання виноградів до групи
/api/v1/vineyards/{vineyardId}/groups/{groupId}/vines	DELETE	Видалення виноградів з групи
/api/v1/vineyards/{vineyardId}/blocks	GET	Отримання всіх блоків у винограднику
/api/v1/vineyards/{vineyardId}/blocks	POST	Створення нового блоку у винограднику
/api/v1/vineyards/{vineyardId}/blocks/{blockId}/_report	POST	Генерація звіту для блоку у винограднику

Продовження таблиці 1
/api/v1/vines/{vineId}/devices	GET	Отримання деталей пристрою за ID
/api/v1/vines/{vineId}/devices	POST	Створення нового пристрою в винограді
/api/v1/vines/{vineId}/devices/{deviceId}/deactivate	POST	Деактивація пристрою
/api/v1/vines/{vineId}/devices/{deviceId}/activate/{frequency}	POST	Активація пристрою з вказаною частотою
/api/v1/users/unblock	POST	Розблокування користувача
/api/v1/users/block	POST	Блокування користувача
/api/v1/db-backups	GET	Отримання списку доступних бекапів
/api/v1/db-backups	POST	Створення бекапу бази даних
/api/v1/blocks/{blockId}/vines	GET	Отримання всіх виноградів у блоку
/api/v1/blocks/{blockId}/vines	POST	Створення нового винограду у блоку
/api/v1/auth/register	POST	Реєстрація нового користувача
/api/v1/auth/refresh	POST	Оновлення access токена
/api/v1/auth/authenticate	POST	Аутентифікація користувача
/api/v1/vineyards/{vineyardId}/groups/{groupId}/_vines_to_assign	GET	Отримання виноградів, що можна призначити групі
/api/v1/users/{id}	GET	Отримання деталей користувача за ID


Кінець таблиці 1
/api/v1/users/me	GET	Отримання деталей поточного автентифікованого користувача
/api/v1/demo/hello	GET	Демонстраційний запит

5.4 Опис частин програмного коду

	Точкою запуску програми є файл VitisVisionApplication.java, код якого наведено в додатку Б.1.
	Захист системи налаштований у конфігураційному файлі SecurityConfig.java, код якого наведено в додатку Б.2. В ньому визначаються правила захисту посилань запитів, визначені які треба захистити аутентифікацією та авторизацією, а які ні. Також конфігуруються посилання та оброблювач виходу із системи та фільтр який буде перехоплювати запити і встановлювати доступ до системи. Сам фільтр JwtAuthenticationFilter в одноіменному файлі з розширенням .java, код якого можна знайти в додатку Б.3, перевіряє наявність jwt токену та його валідність за часом і підписом за допомогою методів JwtService.java, код якого  можна знайти в додатку Б.4, і заносить користувача в SecurityContext тим самим дозволяє користувачу користуватися системою.
	Також в системі є глобальний обробник виключних ситуацій, знаходиться в файлі GlobalAdvisor.java в додатку Б.5, який перехоплює та обробляє усі виключення, які можуть виникнути під час роботи програми. Під час виключної ситуації, її обробляють та формують відповідь користувачу про те, що було причиною.  Для цього у виді відповіді виступає ApiError.java, його код у додатку Б.6, який і є структурою оформлення подібних «виключних» відповідей. Помилка, наприклад, може виникнути через невірні вхідні данні від користувача, тоді валідатори цих даних і повідомляють про це у вигляді ApiError.
 
6 ПРИСТРІЙ ІНТЕРНЕТУ РЕЧЕЙ
6.1 Опис інженерних рішень

	Для створення програмного забезпечення для IoT пристрою було використано симулятор Wokwi. Код для пристрою написаний на мові програмування С++. У якості IoT пристрою виступає пристрій для відстеження довкілля, що вимірює вологість і температуру як повітря так і грунту. Крім того, пристрій використовує люксометр для вимірювання освітленості. Пристрій складається із мікроконтролера ESP32, двох датчиків DHT, фоторезистора та LCD дисплею (рис. 6.1). 

 
Рисунок 6.1 – Будова IoT пристрою 

6.2 Пояснення програмного коду

	Після запуску пристрою, користувач має змогу вказати бажану величину швидкості передачі даних пристрою (Baud rate). Після встановлення цього параметру, у користувача запитується ID пристрою. ID служить для асоціації пристрою з певними лозами. Після цього він автоматично шукає доступні мережі Wi-fi для підключення до інтернету. Частина коду, відповідальна за це зазначена нижче:
1 // Scan for available networks
2 int numNetworks = WiFi.scanNetworks();
3 Serial.println("Available networks:");
4 for (int i = 0; i < numNetworks && i < MAX_NETWORKS; i++) {
5    availableNetworks[i].ssid = WiFi.SSID(i);
6    availableNetworks[i].password = "";
7 Serial.println(String(i) + "#" + availableNetworks[i].ssid);
8 }
	Потім користувач може обрати мережі, до яких він може приєднатись. Для подальшої роботи пристрою необхідно налаштувати веб-сервер. Після цього процесу, відкриваються 2 точки доступу до нього. Перша, це відповідає за початок процесу спостереження та збору даних з датчиків з певною періодичністю, яку користувач зазначає в тілі запиту методу POST. Знизу зображений код відповідальний за ці дії:
1   server.on("/" + String(deviceID) + "/start", HTTP_POST, []() {
2       if (measuring) {
3           server.send(400, "application/json", "{\"error\":\"Measurement already in progress\"}");
4           return;
5       }
6   
7       String requestBody = server.arg("plain");
8       JsonDocument doc;
9       DeserializationError error = deserializeJson(doc, requestBody);
10  
11      if (error) {
12          server.send(400, "application/json", "{\"error\":\"Invalid request\"}");
13          return;
14      }
15  
16      measureFrequency = doc["frequency"].as<int>() * 1000;
17      setTimeFromString(doc["timestamp"].as<String>());
18  
19      startMeasure();
20      server.send(200, "application/json", "{\"message\":\"Measurement started\"}");
21  }); 
Друга точка доступу сигналізую пристрою щоб той припиняв свою роботу і надсилав, зібрані за час після першого запиту, дані на сервер у відповідь.
Параметри, які користувач передає через тіло запиту валідуються, і в разі виникнення помилки опрацювання значень цих параметрів, пристрій повідомить сервер відповідною відповіддю на його запит, тобто поверне 400 код (BAD_REQUEST) та пояснююче повідомлення.
Логіка збору даних періодично написана у головній функції loop(), її код наведено нижче:
1   void loop() { // Main loop function
2       server.handleClient();
3       if (measuring && millis() - lastMeasurement >= measureFrequency) {
4           readData();
5           lastMeasurement = millis(); // Update the last measurement time
6       }
7       delay(50);
8   }
Для вирахування значення освітленості із значення опору, під час опромінення світлом фоторезистора, використаємо формулу, яка наведена у коді нижче:
1   float calculateLux(float LdrValue){ 
2       float voltage = LdrValue / 1024.0 * 5.0 / 4.0;  
3       float resistance = 2000.0 * voltage / (1 - voltage / 5.0); 
4       float lux = pow(RL10 * 1000.0 * pow(10.0, GAMMA) / resistance, 1.0 / GAMMA);  
5       return lux;  
6   }
Для синхронізації часу пристрою з сервером, цей час передається у тілі до POST запиту сервером, який знає актуальний час, і цей час встановлюється на пристрої. Пристрій фіксує дані у визначений сервером час, що нівелює у повній мірі неточність у синхронізації пристрою і серверу. Код, який відповідає за встановлення часу пристрою, наведено нижче:
1   void setTimeFromString(String timeString) {  // Set the time of the device from a string in ISO 8601 format
2       struct tm tm;
3       strptime(timeString.c_str(), "%Y-%m-%dT%H:%M:%SZ", &tm); // Parse the time string into a tm structure
4       time_t t = mktime(&tm); // Convert tm structure to time_t
5       struct timeval now = { .tv_sec = t }; // Create a timeval structure with the converted time
6       settimeofday(&now, NULL); // Set the system time
7  }
Сервер після запиту для отримання даних, у відповіді має детальний звіт у форматі JSON з усіма необхідними даними і часовими мітками у форматі масиву JSON об’єктів. Приклад таких об’єктів наведено нижче:
    "data": [
        {
            "air_temperature": 24.00,
            "air_humidity": 40.00,
            "gnd_temperature": 20.00,
            "gnd_humidity": 48.00,
            "lux": 499.86,
            "timestamp": "2024-05-07T08:25:00Z"
        },
        {
            "air_temperature": 23.00,
            "air_humidity": 40.00,
            "gnd_temperature": 21.00,
            "gnd_humidity": 48.00,
            "lux": 501.24,
            "timestamp": "2024-05-07T08:25:01Z"
       }, …

	Також варто відзанчити структуру проекту, код розділений на визначену кількість файлі, кожен з яких містить свою частину функціоналу, що робить код більш зручним для підтримки. Щоб звести до мінімуму потенціал помилок, використовуються файли заголовків для зберігання оголошень змінних та функцій підмодулю. Файлова структура наведена нижче:
src/
lcd.cpp
lcd.h
measure.cpp
measure.h
network.cpp
network.h
sensor.cpp
sensor.h
server.cpp
utils.cpp
utils.h


6.3 Розробка діаграм

Для ІоТ пристрою було створено діаграму прецедентів (рис. 6.2). Для використання пристрою зазначено одного актора - Користувач. Для нього доступні можливості вибрати Wi-fi для підключення, встановити ID пристрою та ввести швидкість передачі даних. Також користувач має можливість встановлювати періодичність збору даних як параметри запиту.

 
Рисунок 6.2 – Use-case діаграма IoT пристрою для програмної системи

	Також було створено діаграму взаємодії (рис. 6.3). Вона надає можливість візуалізувати, як компоненти IoT пристрою взаємодіють між собою в межах системи. Крім того, вона дозволяє зрозуміти логіку роботи пристрою.

 
Рисунок 6.3 – Діаграма взаємодії IoT пристрою для програмної системи

	Діаграма пакетів для ІоТ пристрою містить 6 пакетів (рис. 6.4). Сервер є головним пакетом, який містить основну логіку роботи програми та керує використання інших компонентів.

 
Рисунок 6.4 – Діаграма пакетів IoT пристрою для програмної системи

	Також було створено діаграму активності (рис. 6.5). Ця діаграма в загальних рисах показує процес роботи ІоТ пристрою. Вона надає можливість зрозуміти дії та процеси, що відбувається в системі.

 
Рисунок 6.5 – Діаграма діяльності IoT пристрою для програмної системи

	Таким чином була спроектована і розроблена серверна частина.
 
7 ВЕБ-КЛІЄНТ
7.1 Опис інженерних рішень

	Для створення програмного забезпечення для клієнтської частини платформи було використано фреймворк з відкритим кодом Angular 16 версії. Код написаний на мові програмування TypeScript, розмітка сторінок у форматі HTML 5, використана бібліотека стилей Bootstrap 5. Використовувалась інтергрована середа розробки WebStorm 2023 компанії JetBrains. Для роботи з jwt токенами у застосунку було використано бібліотеку auth0/angular-jwt.
	Кореневою папкою проекта є папка src (файлова структура проекту наведена в додатку В). В ній знаходяться шаблонні файли, папка з графічним вмістом та папка з самим проектом (папка app). У папці app знаходяться файли головного компоненту, папка з модулями, які містять в собі інші дочірні компоненти та папка з сервісами застосунку, які відповідають за логіку його взаємодії з серверною частиною.

7.2 Пояснення програмного коду

	При запуску застосунку основним файлом, що виконується, є main.ts, який ініціалізує запуск модулів Angular. Точка входу описана наступним чином:
1 import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
2 import { AppModule } from './app/app.module';
3 
4 platformBrowserDynamic().bootstrapModule(AppModule)
5   .catch(err => console.error(err));
	Після ініціалізації в main.ts управління передається до AppModule, який є головним модулем застосунку. В AppModule зібрані всі основні компоненти, сервіси та модулі, що визначають структуру застосунку. Модуль описано так:
1 @NgModule({
2   declarations: [
3     AppComponent  // Головний компонент застосунку
4   ],
5   imports: [
6     BrowserModule,        // Модуль для запуску додатку в браузері
7     AppRoutingModule,     // Модуль для маршрутизації у застосунку
8     HttpClientModule,     // Модуль для виконання HTTP запитів
9     CoreModule            // Власний модуль, що містить сервіси та інші ядрові компоненти
10  ],
11  providers: [
12    HttpClient,           // Сервіс для виконання HTTP запитів
13    {
14      provide: HTTP_INTERCEPTORS,
15      useClass: HttpTokenInterceptor, // Перехоплювач для додавання токену авторизації до запитів
16      multi: true
17    },
18  ],
19  bootstrap: [AppComponent] // Вказує Angular запустити AppComponent як кореневий компонент
20 })
21 export class AppModule {
22 }
AppComponent є кореневим компонентом, який Angular додає до DOM при запуску додатку. Життєвий цикл застосунку починається з AppComponent, де може відбуватися ініціалізація даних або перевірка авторизації користувача.
Компоненти, сервіси та перехоплювачі, включені до AppModule, забезпечують основу для функціонування застосунку. Використання HttpClientModule дозволяє виконувати асинхронні запити до сервера, а модуль CoreModule збирає всі необхідні ядрові компоненти і сервіси, що використовуються на багатьох сторінках застосунку. Система маршрутизації, визначена в AppRoutingModule, керує навігацією в застосунку, а HttpTokenInterceptor автоматично додає токен авторизації до кожного вихідного запиту, забезпечуючи безпечний обмін даними.
Структура основного шаблону застосунку має стандартний вигляд, в якому застосовано кілька ключових компонент Angular для керування вмістом та навігацією:
1 <app-header></app-header>
2 <router-outlet></router-outlet>
3 <app-footer></app-footer>
<app-header></app-header> – Компонент "шапки" веб-додатку. Він зазвичай містить навігаційне меню, логотип та інші елементи інтерфейсу, які мають бути доступні користувачу на всіх сторінках застосунку. Цей компонент залишається сталим і не змінюється при переходах між сторінками.
<router-outlet></router-outlet> – Директива Angular Router, яка служить як місце, куди динамічно завантажуються різні компоненти в залежності від взаємодії користувача з додатком та поточного маршруту. Router Outlet використовується для зміни відображеного контенту без перезавантаження сторінки, що дозволяє реалізувати односторінкові застосунки (SPA).
<app-footer></app-footer> – Компонент "підвалу" застосунку, який зазвичай містить інформацію про авторські права, посилання на політику конфіденційності, контактні дані та інші корисні посилання, які користувач може потребувати незалежно від відвідуваної сторінки. Як і "шапка", "підвал" є сталим елементом, що не змінюється при навігації застосунку.
У файлі app-routing.module.ts додатку Angular визначені маршрути для навігації між різними модулями. Ці шляхи включають ліниве завантаження модулів для оптимізації продуктивності та розподілу залежностей за потребою. За допомогою authGuard, деякі шляхи захищені, забезпечуючи доступ лише для аутентифікованих користувачів. Ось приклад роутінгу: 
1   {
2     path: 'vineyard',
3     loadChildren: () => import('./modules/vineyard/vineyard.module').then(m => m.VineyardModule),
4     canActivate: [authGuard]
5   },
Цей маршрут веде до модуля VineyardModule, який включає VineyardComponent, що відповідає за управління даними виноградників.
Компонент VineyardComponent використовується для управління інформацією про виноградники та пов'язані з ними елементи, такі як блоки, групи та персонал. Взаємодія з сервером відбувається через різні сервіси, включені в компонент. Нижче описано ключові аспекти взаємодії з сервером на основі коду компонента:
1.	Ініціалізація та завантаження даних про користувача:
1 ngOnInit(): void {
2   this.userService.getMe().subscribe({
3     next: (res) => {
4       console.log(res.data)
5       this.user = res.data as UserResponse;
6       this.getVineyard(Number(this.user.vineyardId));
7     },
8   });
9 }
При ініціалізації компонента виконується запит до сервісу UserService для отримання даних про користувача, після чого відбувається завантаження даних про виноградник.
2.	Завантаження інформації про виноградник:
1 private getVineyard(id: number) {
 2   this.vineyardService.getVineyard({vineyardId: id}).subscribe({
 3     next: (res) => {
 4       console.log(res.data)
 5       const response = res.data as VineyardResponse;
 6       this.vineyard = response;
 7       // ...
 8       this.getStaff(res.data?.id as number);
 9       this.getBlocks(res.data?.id as number);
10       this.getGroups(res.data?.id as number);
11     },
12   });
Завантаження деталей виноградника з сервера і подальше завантаження пов'язаної інформації про персонал, блоки та групи. Повний код цього компоненту можна подивитись у додатку Г.
3. Створення, редагування та видалення даних: Функції, такі як createVineyard(), editVineyard(), і deleteVineyard(), використовують відповідні сервіси для взаємодії з сервером, відправляючи POST, PUT або DELETE запити для управління даними.
4. Обробка помилок:
Під час виконання операцій, помилки, які повертає сервер, збираються та відображаються для інформування користувача про необхідність виправлень. До речі, сервер повертає помилки у певному форматі, в додатку є інтерфейс, який відображає структуру цього формату:
1 export interface ApiError {
2   details?: string;
3   message?: string;
4   status?: number;
5   timestamp?: string;
6 }
Розмітка компонента VineyardComponent зосереджена на управлінні виноградником, але зараз розглянемо частину пов’язану з можливістю створення нового виноградника. Основні аспекти розмітки включають візуальні елементи, умовні відображення, валідацію форм і динамічну взаємодію з користувачем. Детальніше про ключові моменти розмітки:
1.	Умовне відображення компонентів:
-	Відображення повідомлення про відсутність виноградника: Якщо у користувача немає асоційованого виноградника, виводиться повідомлення про це:
1 <div *ngIf="!vineyard.id">
2 <p class="text-center">You are not a member of any Vineyard.</p>
-	Перемикач для відображення форми створення виноградника: За допомогою кнопок користувач може відкрити або закрити форму створення виноградника:
1 <a *ngIf="!createVineyardMode" (click) ="toggleCreateVineyard()">
2 <button type="button" class="btn btn-dark mb-4">Create Vineyard</button></a>

2.	Валідація та повідомлення про помилки:
-	Відображення помилок: Якщо при створенні виноградника виникають помилки, вони відображаються через список:
1 <div class="alert alert-danger" role="alert" *ngIf="createVineyardErrorMessages.length">
  2 <p *ngFor="let msg of createVineyardErrorMessages">{{ msg.message }}</p>
3 </div>
-	Валідація полів: Усі поля вимагають заповнення (required), і кнопка створення блокується, якщо не всі поля заповнені:
1 <button class="btn btn-lg btn-outline-dark mb-4"
2 		(click)="createVineyard()"
3 		[disabled]="!createVineyardRequest.dbaName || !createVineyardRequest.companyName || ...
4 		!createVineyardRequest.zipCode">Create
5 </button>
3.	Динамічна взаємодія:
-	Two-way data binding ([(ngModel)]): Це забезпечує синхронізацію значень полів у формі з властивостями компонента, що полегшує збір та відправку даних:
1	<input type="text" id="dba" name="dba" [(ngModel)]="createVineyardRequest.dbaName" ...>
-	Обробники подій: Кнопки та інші елементи інтерфейсу мають обробники подій, такі як (click), які активують методи компонента для виконання дій (наприклад, створення виноградника):
1 (click)="createVineyard()"
Ця розмітка демонструє гнучке управління станом інтерфейсу з допомогою Angular-специфічних директив і зв'язування даних, забезпечуючи інтуїтивно зрозумілі та зручні для користувача механізми для взаємодії з веб-додатком.
Також варто зауважити, що сайт підтримує локалізацію інтерфейсу та підтримує дві локалі: українську та англійську. Для реалізації цього було використано бібліотеку ngx-translate.
Засоби, які реалізовані в цій бібліотеці дозволяють змінювати локалізацію під час виконання програми на льоту. Зміна локалізації керується за допомогою типу та пайпу translate. Код наведено нижче:
1 translate.addLangs(['en', 'ua']);
2 translate.setDefaultLang('en');
3 const browserLang = translate.getBrowserLang();
4 translate.use(browserLang?.match(/en|ua/) ? browserLang : 'en');
Відображення тексту відбувається з файлів з папки assets/i18n таким чином:
1 <li *ngIf="isUserAuthenticated()"><a routerLink="/vineyard" class="nav-link px-3 link-dark">{{ 'HEADER.VINEYARD' | translate }}</a></li>
2 <li *ngIf="isUserAuthenticated()" ><a routerLink="/profile" class="nav-link px-3 link-dark">{{ 'HEADER.PROFILE' | translate }}</a></li>

7.3 Розробка діаграм

Для візуального представлення взаємодії між користувачами і системою була розроблена Use Case діаграма (рис. 7.1).

 
Рисунок 7.1 – Use-case діаграма клієнтської частини

	Також було створено діаграму компонентів (рис. 7.2). Вона надає можливість візуалізувати, як компоненти клієнтської частини взаємодіють між собою в межах системи. Крім того, вона дозволяє зрозуміти логіку роботи частини.

  
Рисунок 7.2 – Діаграма компонентів клієнтської частини
	
	Діаграма пакетів для клієнтської частини містить 17 пакетів (рис. 7.3). Зображено два основні пакети (modules, core), 9 підпакетів всередині modules та 8 підпакетів у батьківському пакеті core. Усі зв’язки між усими пакетами продемонстровані вкладеннями та стрілками.

 
Рисунок 7.3 – Діаграма пакетів клієнтської частини

	Також було створено діаграму станів (рис. 7.4). Ця діаграма в загальних рисах показує процес роботи і взаємодію користувача з інтерфейсом. Також вона певною мірою надає можливість зрозуміти дії та процеси, що відбувається в системі.

 
Рисунок 7.4 – Діаграма станів клієнтської частини
	
Таким чином була спроектована і розроблена клієнтська частина.
	За необхідністю переглянути вихідний код усіх розроблених частин зверніться за посиланням у переліку джерел [5].
ВИСНОВКИ
	
В результаті виконання курсової роботи було досягнуто основної мети – створено програмну систему для управління виноградниками. Розроблена система надає користувачам такі можливості: авторизація, створення нових акаунтів та керування власним профілем для працівників виноградників, облік виноградної лози, організація лоз винограду у групи та блоки за певними критеріями, управління роботою пристроїв, керування штатом винограднику, зокрема найм та звільнення працівників, зміна їх посади, моніторинг стану виноградної лози та ґрунту, адміністрування користувачами, надійний захист даних, створення резервних копій бази даних, аналізу даних для прийняття рішень та створення статистичних звітів. Крім того, система підтримує українську та англійську локалізацію, що робить її зручною для користувачів з різних країн. Таким чином, розроблена програмна система дозволить значно покращити ефективність управління виноградниками та догляду за лозами.
Для створення системи було використано сучасні технології, зокрема Spring Boot для розробки серверної частини, Angular для клієнтської частини та IoT пристрої на основі мікроконтролера ESP32. Серверна частина забезпечує збереження та обробку даних за допомогою PostgreSQL, а клієнтська частина надає зручний інтерфейс користувача для взаємодії з системою.
Тестування системи [6] показало її високу функціональність та ефективність. В майбутньому можливе розширення функціоналу системи за рахунок розробки алгоритму кластерного аналізу для ідентифікації схожих ділянок, алгоритму виявлення тенденцій агрометеорологічних умов, за допомогою аналізу часових рядів, розробки мобільного додатку для виноградарів, розробки система попереджень на основі прогнозу погоди, впровадження управління графіками та правилами зрошення виноградних кущів.
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1.	Viticulture, a key sector for agricultural mechanics | Mondo Macchine / Machinery World. URL: https://www.mondomacchina.it/en/viticulture-key-sector-for-agricultural-mechanics-c3387 (дата звернення: 03.06.2024).
2.	IoT devices (internet of things devices) | www.techtarget.com. URL: https://www.techtarget.com/iotagenda/definition/IoT-device (дата звернення: 03.06.2024).
3.	Introduction to JSON Web Tokens. URL: https://jwt.io/introduction (дата звернення: 03.06.2024).
4.	Spring Data JPA. Spring Data JPA Overview. URL: https://spring.io/projects/spring-data-jpa (дата звернення: 03.06.2024).
5.	GitHub - NurePyrohAndrii/apzkr-pzpi-21-3-pyroh-andrii. GitHub. URL: https://github.com/NurePyrohAndrii/apzkr-pzpi-21-3-pyroh-andrii (дата звернення: 05.06.2024).
6.	АПЗ ПЗПІ 21 3 Пирог Андрій Курсова робота | Андрій Пирог. YouTube. URL: https://youtu.be/E1MT6x_ulKE (дата звернення: 06.06.2024).
ДОДАТОК А
Результат перевірки на плагіат

 
ДОДАТОК Б
Частини програмного коду серверної частини

Б.1 Код файлу VitisVisionApplication.java
1  /**
2  * The main class for the Spring Boot application.
3  */
4  @SpringBootApplication
5  public class VitisVisionServiceApplication {
6  
7      /**
8      * The main method to start the Spring Boot application.
9      *
10     * @param args The command line arguments.
11     */
12    public static void main(String[] args) {
13        SpringApplication.run(VitisVisionServiceApplication.class, args);
14    }
15
16    //@Bean
17    public CommandLineRunner run(StartupSeeder startupSeeder) {
18        return args -> startupSeeder.run();
19    }
20
21 }

Б.2 Код файлу SecurityConfig.java

1  /**
2  * SecurityFilterChainConfig class is used to configure the security filter chain that will be used to secure the application.
3  */
4  @EnableWebSecurity
5  @Configuration
6  @RequiredArgsConstructor
7  @EnableMethodSecurity
8  public class SecurityFilterChainConfig {
9  
10     /**
11     * List of white listed URLs that are allowed to be accessed without authentication.
12     */
13    private static final String[] WHITE_LIST_URL = {
14            "/api/v1/auth/**",
15            "/swagger-ui/**",
16            "/swagger-ui.html",
17            "/v2/api-docs",
18            "/v3/api-docs",
19            "/v3/api-docs/**",
20            "/swagger-resources",
21            "/swagger-resources/**"
22    };
23
24     /**
25     * JwtAuthenticationFilter bean that will be used to authenticate the user using JWT token.
26     */
27    private final JwtAuthenticationFilter jwtAuthenticationFilter;
28
29     /**
30     * AuthenticationProvider bean that will be used to authenticate the user.
31     */
32    private final AuthenticationProvider authenticationProvider;
33
34     /**
35     * LogoutHandler bean that will be used to handle the logout request.
36     */
37    private final LogoutHandler logoutHandler;
38
39     /**
40     * CorsConfigurationSource bean that will be used to configure the CORS policy.
41     */
42    private final CorsConfigurationSource corsConfigurationSource;
43
44     /**
45     * Method to configure the security filter chain that will be used to secure the application.
46     * @param http HttpSecurity object that will be used to configure the security filter chain.
47     * @return SecurityFilterChain object that will be used to secure the application.
48     * @throws Exception Exception that will be thrown if any error occurs.
49     */
50    @Bean
51    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
52        return http
53                .csrf(AbstractHttpConfigurer::disable)
54                .cors(cors -> cors.configurationSource(corsConfigurationSource))
55                .authorizeHttpRequests(
56                        req -> req
57                                .requestMatchers(WHITE_LIST_URL)
58                                .permitAll()
59                                .anyRequest()
60                                .authenticated()
61                )
62                .sessionManagement(session -> session.sessionCreationPolicy(STATELESS))
63                .authenticationProvider(authenticationProvider)
64                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
65                .logout(logout -> {
66                    logout.logoutUrl("/api/v1/auth/logout");
67                    logout.addLogoutHandler(logoutHandler);
68                    logout.logoutSuccessHandler(
69                            (request, response, authentication) ->
70                                    SecurityContextHolder.clearContext());
71                })
72                .build();
73    }
74
75 }

Б.3 Код файлу JwtAuthenticationFilter.java

1  /**
2  * This class is responsible for authenticating the request using JWT token
3  */
4  @Component
5  public class JwtAuthenticationFilter extends OncePerRequestFilter {
6  
7      /**
8      * The JwtService object to handle JWT operations
9      */
10     private final JwtService jwtService;
11
12     /**
13     * The UserDetailsService object to load user details
14     */
15     private final UserDetailsService userDetailsService;
16
17     /**
18     * The JwtFilterExceptionHandler object to handle JWT exceptions
19     */
20     private final JwtFilterExceptionHandler jwtExceptionHandler;
21
22     /**
23     * The TokenRepository object to interact with the token persistence
24     */
25     private final TokenRepository tokenRepository;
26
27     /**
28     * Constructor to initialize the JwtAuthenticationFilter object
29     *
30     * @param jwtService          the JwtService object
31     * @param userDetailsService  the UserDetailsService object qualified with "userDetailsServiceImpl"
32     * @param jwtExceptionHandler the JwtFilterExceptionHandler object
33     * @param tokenRepository     the TokenRepository object
34     */
35    public JwtAuthenticationFilter(
36            JwtService jwtService,
37            @Qualifier("userDetailsServiceImpl") UserDetailsService userDetailsService,
38            JwtFilterExceptionHandler jwtExceptionHandler,
39            TokenRepository tokenRepository
40    ) {
41        this.jwtService = jwtService;
42        this.userDetailsService = userDetailsService;
43        this.jwtExceptionHandler = jwtExceptionHandler;
44        this.tokenRepository = tokenRepository;
45    }
46
47     /**
48     * This method is called by the filter chain to authenticate the request
49     *
50     * @param request     the request object
51     * @param response    the response object
52     * @param filterChain the filter chain object
53     * @throws ServletException if an error occurs while processing the request
54     * @throws IOException      if an error occurs while reading the request
55     */
56    @Override
57    public void doFilterInternal(
58            @NonNull HttpServletRequest request,
59            @NonNull HttpServletResponse response,
60            @NonNull FilterChain filterChain
61    ) throws ServletException, IOException {
62        // TODO: handle more exceptions there (AccessDeniedException, AuthenticationException, etc.)
63        Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);
64        logger.info("[authenticating...] doFilterInternal(..) method called");
65
66        boolean isDebugEnabled = logger.isDebugEnabled();
67        if (isDebugEnabled)
68            logger.debug("[%s] %s(..) method arguments : %s"
69                    .formatted(
70                            "authenticating...",
71                            "doFilterInternal(..)",
72                            Arrays.toString(new Object[]{request, response, filterChain})
73                    )
74            );
75
76        final String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION);
77        final String jwt;
78        String userEmail = null;
79
80        if (Objects.isNull(authHeader) || !authHeader.startsWith("Bearer ")) {
81            filterChain.doFilter(request, response);
82            return;
83        }
84
85        MDC.put("context", "authenticating...");
86        jwt = authHeader.substring(7);
87
88
89        try {
90            userEmail = jwtService.extractEmail(jwt);
91            MDC.put("context", userEmail);
92
93            if (Objects.nonNull(userEmail)
94                    && Objects.isNull(SecurityContextHolder.getContext().getAuthentication())) {
95                UserDetails userDetails = userDetailsService.loadUserByUsername(userEmail);
96                Optional<Token> token = tokenRepository.findByToken(jwt);
97
98                boolean isDbRefreshTokenValid = token
99                        .map(t -> !t.isExpired() && !t.isRevoked() && t.getTokenType() == TokenType.REFRESH)
100                       .orElse(false);
101
102               boolean isProvidedRefreshTokenValid = jwtService.isTokenValid(jwt, userDetails);
103
104               // if token is refresh, then let it pass
105               if (isDbRefreshTokenValid && isProvidedRefreshTokenValid) {
106                   if (isDebugEnabled)
107                       logger.debug("[%s] %s(..) method returned : %s".formatted(userEmail, "doFilterInternal(..)", "void"));
108                   filterChain.doFilter(request, response);
109                   return;
110               }
111
112               boolean isAccessTokenValid = token
113                       .map(t -> !t.isExpired() && !t.isRevoked() && t.getTokenType() == TokenType.ACCESS)
114                       .orElse(false);
115
116               if (isProvidedRefreshTokenValid && isAccessTokenValid) {
117                   UsernamePasswordAuthenticationToken authToken =
118                           new UsernamePasswordAuthenticationToken(
119                                   userDetails, null, userDetails.getAuthorities()
120                           );
121                   authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
122                   SecurityContextHolder.getContext().setAuthentication(authToken);
123
124                   if (isDebugEnabled)
125                       logger.debug("[%s] %s(..) method returned : %s".formatted(userEmail, "doFilterInternal(..)", "void"));
126               } else {
127                   JwtException jwtException = new JwtException("invalid.jwt");
128                   if (isDebugEnabled)
129                       logger.warn("[%s] %s(..) method threw an exception : %s".formatted(userEmail, "doFilterInternal(..)", jwtException));
130                   jwtExceptionHandler.handleJwtException(response, jwtException);
131               }
132
133           }
134
135           if (isDebugEnabled) {
136               logger.debug("[%s] %s(..) method returned : %s".formatted(userEmail, "doFilterInternal(..)", "void"));
137           }
138           filterChain.doFilter(request, response);
139       } catch (JwtException e) {
140           logger.error("[%s] %s(..) method threw an exception : %s"
141                   .formatted(userEmail, "doFilterInternal(..)", e));
142           jwtExceptionHandler.handleJwtException(response, e);
143       }
144   }
145 }

Б.4 Код файлу JwtService

1  @Service
2  public class JwtService {
3      @Value("${application.security.jwt.secret-key}")
4      private String SECRET_KEY;
5      @Value("${application.security.jwt.expiration}")
6      private long jwtExpiration
7      public String extractUserEmail(String token) {
8          return extractClaim(token, Claims::getSubject);
9      }
10     public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
11         final Claims claims = extractAllClaims(token);
12         return claimsResolver.apply(claims);
13     }
14     public String generateToken(UserDetails userDetails) {
15         return generateToken(new HashMap<>(), userDetails);
16     }
17     public String generateToken(
18             Map<String, Object> extraClaims,
19             UserDetails userDetails
20     ) {
21         return Jwts
22                 .builder()
23                 .setClaims(extraClaims)
24                 .setSubject(userDetails.getUsername())
25                 .setIssuedAt(new Date(System.currentTimeMillis()))
26                 .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration))
27                 .signWith(getSigningKey(), SignatureAlgorithm.HS256)
28                 .compact();
29     }
30     public boolean isTokenValid(String token, UserDetails userDetails) {
31         final String userEmail = extractUserEmail(token);
32         return userEmail.equals(userDetails.getUsername()) && !isTokenExpired(token);
33     }
34     private boolean isTokenExpired(String token) {
35         return extractExpiration(token).before(new Date());
36     }
37     private Date extractExpiration(String token) {
38         return extractClaim(token, Claims::getExpiration);
39     }
40     private Claims extractAllClaims(String token) {
41         return Jwts
42                 .parserBuilder()
43                 .setSigningKey(getSigningKey())
44                 .build()
45                 .parseClaimsJws(token)
46                 .getBody();
47     }
48     private Key getSigningKey() {
49         byte[] keyBytes = Decoders.BASE64.decode(SECRET_KEY);
50         return Keys.hmacShaKeyFor(keyBytes);
51     }
52 }

Б.5 Код файлу GlobalAdvisor.java

1  /**
2  * DefaultExceptionHandler class is a global exception handler for the application.
3  */
4  @ControllerAdvice
5  @RequiredArgsConstructor
6  public class GlobalAdvisor {
7  
8      /**
9      * The AdvisorUtils object that contains utility methods.
10     */
11    private final AdvisorUtils advisorUtils;
12
13     /**
14     * The MessageSourceUtils object that contains utility methods for message source.
15     */
16    private final MessageSourceUtils messageSourceUtils;
17
18     /**
19     * Handle all exceptions.
20     *
21     * @param e the exception object of type {@link Throwable}
22     * @return the response entity
23     */
24    @ExceptionHandler(Throwable.class)
25    public ResponseEntity<ApiResponse<List<ApiError>>> handleException(Exception e) {
26        List<ApiError> errors = List.of(
27                new ApiError(
28                        HttpStatus.INTERNAL_SERVER_ERROR,
29                        messageSourceUtils.getLocalizedMessage("global.error"),
30                        advisorUtils.getErrorDetailsString(e),
31                        LocalDateTime.now().toString()
32                )
33        );
34
35        return advisorUtils.createErrorResponseEntity(errors, HttpStatus.INTERNAL_SERVER_ERROR);
36    }
37
38     /**
39     * Handle validation exception that occurs when a request body is not valid or has validation errors.
40     *
41     * @param ex the exception object of type {@link MethodArgumentNotValidException}
42     * @return the response entity with the list of errors
43     */
44    @ExceptionHandler(MethodArgumentNotValidException.class)
45    public ResponseEntity<ApiResponse<List<ApiError>>> handleValidationException(MethodArgumentNotValidException ex) {
46        List<ApiError> errors = ex.getAllErrors().stream()
47                .map(err -> new ApiError(
48                        HttpStatus.UNPROCESSABLE_ENTITY,
49                        messageSourceUtils.getLocalizedMessage(err.getDefaultMessage()),
50                        messageSourceUtils.getLocalizedMessage("validation.error"),
51                        LocalDateTime.now().toString()
52                ))
53                .toList();
54
55        return advisorUtils.createErrorResponseEntity(errors, HttpStatus.UNPROCESSABLE_ENTITY);
56    }
57
58     /**
59     * Handle access denied exception that occurs when a user tries to access a resource without proper permissions.
60     *
61     * @param e the exception object of type {@link AccessDeniedException}
62     * @return the response entity with the list of errors
63     */
64    @ExceptionHandler(AccessDeniedException.class)
65    public ResponseEntity<ApiResponse<List<ApiError>>> handleAccessDeniedException(AccessDeniedException e) {
66        List<ApiError> errors = List.of(
67                new ApiError(
68                        HttpStatus.FORBIDDEN,
69                        messageSourceUtils.getLocalizedMessage("error.access.denied"),
70                        advisorUtils.getErrorDetailsString(e),
71                        LocalDateTime.now().toString()
72                )
73        );
74
75        return advisorUtils.createErrorResponseEntity(errors, HttpStatus.FORBIDDEN);
76    }
77
78     /**
79     * Handle resource not found exception that occurs when a resource is not found in the database.
80     *
81     * @param e the exception object of type {@link ResourceNotFoundException}
82     * @return the response entity with the list of errors
83     */
84    @ExceptionHandler(ResourceNotFoundException.class)
85    public ResponseEntity<ApiResponse<List<ApiError>>> handleResourceNotFoundException(ResourceNotFoundException e) {
86        return advisorUtils.createErrorResponseEntity(e, HttpStatus.NOT_FOUND);
87    }
88
89     /**
90     * Handle duplicate resource exception that occurs when a resource is already present in the database.
91     *
92     * @param e the exception object of type {@link DuplicateResourceException}
93     * @return the response entity with the list of errors
94     */
95    @ExceptionHandler(DuplicateResourceException.class)
96    public ResponseEntity<ApiResponse<List<ApiError>>> handleDuplicateResourceException(DuplicateResourceException e) {
97        return advisorUtils.createErrorResponseEntity(e, HttpStatus.CONFLICT);
98    }
99
100     /**
101     * Handle illegal argument exception that occurs when an illegal argument is passed to a method.
102     *
103     * @param e the exception object of type {@link IllegalArgumentException}
104     * @return the response entity with the list of errors
105     */
106    @ExceptionHandler(IllegalArgumentException.class)
107    public ResponseEntity<ApiResponse<List<ApiError>>> handleIllegalArgumentException(IllegalArgumentException e) {
108        return advisorUtils.createErrorResponseEntity(e, HttpStatus.BAD_REQUEST);
109    }
110 }

Б.6 Код файлу ApiError.java

1  /**
2  * ApiError class to hold the error details
3  */
4  @AllArgsConstructor
5  @NoArgsConstructor
6  @Data
7  @Builder
8  public class ApiError {
9      /** HttpStatus status of the error response */
10     HttpStatus status;
11
12     /**
13     * Error message to be displayed to the user
14     */
15     String message;
16
17     /**
18     * Details of the error occurred in the application
19     */
20     String details;
21
22     /**
23     * Timestamp of the error occurred
24     */
25     String timestamp;
26 }
 
ДОДАТОК В
Файлова структура клієнтської частини

src
|   favicon.ico
|   index.html
|   main.ts
|   styles.css
|
+---app
|   |   app-routing.module.ts
|   |   app.component.css
|   |   app.component.html
|   |   app.component.spec.ts
|   |   app.component.ts
|   |   app.module.ts
|   |
|   +---core
|   |   |   core.module.ts
|   |   |
|   |   +---api
|   |   |   |   api-configuration.ts
|   |   |   |   api.module.ts
|   |   |   |   base-service.ts
|   |   |   |   models.ts
|   |   |   |   request-builder.ts
|   |   |   |   services.ts
|   |   |   |   strict-http-response.ts
|   |   |   |
|   |   |   +---fn
|   |   |   |   +---authentication
|   |   |   |   |       authenticate.ts
|   |   |   |   |       refresh.ts
|   |   |   |   |       register.ts
|   |   |   |   |
|   |   |   |   +---block
|   |   |   |   |       create-vineyard-1.ts
|   |   |   |   |       delete-block.ts
|   |   |   |   |       generate-block-report.ts
|   |   |   |   |       get-block.ts
|   |   |   |   |       get-blocks.ts
|   |   |   |   |       update-block.ts
|   |   |   |   |
|   |   |   |   +---db-backup-controller
|   |   |   |   |       backup-database.ts
|   |   |   |   |       get-backups.ts
|   |   |   |   |
|   |   |   |   +---demo-controller
|   |   |   |   |       hello.ts
|   |   |   |   |
|   |   |   |   +---device
|   |   |   |   |       activate-device.ts
|   |   |   |   |       create-device.ts
|   |   |   |   |       deactivate-device.ts
|   |   |   |   |       delete-device.ts
|   |   |   |   |       get-device.ts
|   |   |   |   |       update-device.ts
|   |   |   |   |
|   |   |   |   +---group
|   |   |   |   |       add-vines-to-group.ts
|   |   |   |   |       create-group.ts
|   |   |   |   |       delete-group.ts
|   |   |   |   |       get-group.ts
|   |   |   |   |       get-groups.ts
|   |   |   |   |       get-vines-in-group.ts
|   |   |   |   |       get-vines-to-assign.ts
|   |   |   |   |       remove-vines-from-group.ts
|   |   |   |   |       update-group.ts
|   |   |   |   |
|   |   |   |   +---staff
|   |   |   |   |       fire-staff.ts
|   |   |   |   |       get-all-staff.ts
|   |   |   |   |       hire-staff.ts
|   |   |   |   |       update-staff.ts
|   |   |   |   |
|   |   |   |   +---user
|   |   |   |   |       block-user.ts
|   |   |   |   |       change-password.ts
|   |   |   |   |       delete-user-by-id.ts
|   |   |   |   |       delete-user.ts
|   |   |   |   |       get-me.ts
|   |   |   |   |       get-user.ts
|   |   |   |   |       get-users.ts
|   |   |   |   |       unblock-user.ts
|   |   |   |   |       update-user.ts
|   |   |   |   |
|   |   |   |   +---vine
|   |   |   |   |       create-vine.ts
|   |   |   |   |       delete-vine.ts
|   |   |   |   |       get-vine.ts
|   |   |   |   |       get-vines.ts
|   |   |   |   |       update-vine.ts
|   |   |   |   |
|   |   |   |   \---vineyard
|   |   |   |           create-vineyard.ts
|   |   |   |           delete-vineyard.ts
|   |   |   |           get-vineyard.ts
|   |   |   |           get-vineyards.ts
|   |   |   |           update-vineyard.ts
|   |   |   |
|   |   |   +---guard
|   |   |   |       auth.guard.spec.ts
|   |   |   |       auth.guard.ts
|   |   |   |
|   |   |   +---interceptor
|   |   |   |       http-token.interceptor.spec.ts
|   |   |   |       http-token.interceptor.ts
|   |   |   |
|   |   |   +---models
|   |   |   |       api-error.ts
|   |   |   |       api-response-auth-response.ts
|   |   |   |       api-response-block-response.ts
|   |   |   |       api-response-device-activate-response.ts
|   |   |   |       api-response-device-response.ts
|   |   |   |       api-response-group-response.ts
|   |   |   |       api-response-list-db-backup-response.ts
|   |   |   |       api-response-pageable-response-list-block-response.ts
|   |   |   |       api-response-pageable-response-list-group-response.ts
|   |   |   |       api-response-pageable-response-list-group-vine-response.ts
|   |   |   |       api-response-pageable-response-list-staff-response.ts
|   |   |   |       api-response-pageable-response-list-user-response.ts
|   |   |   |       api-response-pageable-response-list-vine-response.ts
|   |   |   |       api-response-pageable-response-list-vineyard-response.ts
|   |   |   |       api-response-staff-response.ts
|   |   |   |       api-response-string.ts
|   |   |   |       api-response-user-response.ts
|   |   |   |       api-response-vine-response.ts
|   |   |   |       api-response-vineyard-response.ts
|   |   |   |       api-response-void.ts
|   |   |   |       auth-response.ts
|   |   |   |       authentication-request.ts
|   |   |   |       block-report-request.ts
|   |   |   |       block-request.ts
|   |   |   |       block-response.ts
|   |   |   |       change-password-request.ts
|   |   |   |       db-backup-response.ts
|   |   |   |       device-activate-response.ts
|   |   |   |       device-request.ts
|   |   |   |       device-response.ts
|   |   |   |       group-request.ts
|   |   |   |       group-response.ts
|   |   |   |       group-vine-response.ts
|   |   |   |       page-metadata.ts
|   |   |   |       pageable-response-list-block-response.ts
|   |   |   |       pageable-response-list-group-response.ts
|   |   |   |       pageable-response-list-group-vine-response.ts
|   |   |   |       pageable-response-list-staff-response.ts
|   |   |   |       pageable-response-list-user-response.ts
|   |   |   |       pageable-response-list-vine-response.ts
|   |   |   |       pageable-response-list-vineyard-response.ts
|   |   |   |       pageable.ts
|   |   |   |       register-request.ts
|   |   |   |       staff-request.ts
|   |   |   |       staff-response.ts
|   |   |   |       user-block-request.ts
|   |   |   |       user-request.ts
|   |   |   |       user-response.ts
|   |   |   |       vine-request.ts
|   |   |   |       vine-response.ts
|   |   |   |       vines-group-assignment-request.ts
|   |   |   |       vineyard-request.ts
|   |   |   |       vineyard-response.ts
|   |   |   |
|   |   |   +---services
|   |   |   |       authentication.service.ts
|   |   |   |       block.service.ts
|   |   |   |       db-backup-controller.service.ts
|   |   |   |       demo-controller.service.ts
|   |   |   |       device.service.ts
|   |   |   |       group.service.ts
|   |   |   |       staff.service.ts
|   |   |   |       user.service.ts
|   |   |   |       vine.service.ts
|   |   |   |       vineyard.service.ts
|   |   |   |
|   |   |   \---token
|   |   |           token.service.spec.ts
|   |   |           token.service.ts
|   |   |
|   |   \---components
|   |       +---footer
|   |       |       footer.component.css
|   |       |       footer.component.html
|   |       |       footer.component.spec.ts
|   |       |       footer.component.ts
|   |       |
|   |       +---header
|   |       |       header.component.css
|   |       |       header.component.html
|   |       |       header.component.spec.ts
|   |       |       header.component.ts
|   |       |
|   |       \---not-found
|   |               not-found.component.css
|   |               not-found.component.html
|   |               not-found.component.spec.ts
|   |               not-found.component.ts
|   |
|   \---modules
|       +---admin
|       |   |   admin-routing.module.ts
|       |   |   admin.module.ts
|       |   |
|       |   \---pages
|       |       \---admin-panel
|       |               admin-panel.component.css
|       |               admin-panel.component.html
|       |               admin-panel.component.spec.ts
|       |               admin-panel.component.ts
|       |
|       +---auth
|       |   |   auth-routing.module.ts
|       |   |   auth.module.ts
|       |   |
|       |   \---pages
|       |       +---login
|       |       |       login.component.css
|       |       |       login.component.html
|       |       |       login.component.spec.ts
|       |       |       login.component.ts
|       |       |
|       |       \---register
|       |               register.component.css
|       |               register.component.html
|       |               register.component.spec.ts
|       |               register.component.ts
|       |
|       +---common
|       |   |   common-routing.module.ts
|       |   |   common.module.ts
|       |   |
|       |   \---pages
|       |       \---home
|       |               home.component.css
|       |               home.component.html
|       |               home.component.spec.ts
|       |               home.component.ts
|       |
|       +---profile
|       |   |   profile-routing.module.ts
|       |   |   profile.module.ts
|       |   |
|       |   \---pages
|       |       \---profile
|       |               profile.component.css
|       |               profile.component.html
|       |               profile.component.spec.ts
|       |               profile.component.ts
|       |
|       \---vineyard
|           |   vineyard-routing.module.ts
|           |   vineyard.module.ts
|           |
|           \---pages
|               +---block
|               |       block.component.css
|               |       block.component.html
|               |       block.component.spec.ts
|               |       block.component.ts
|               |
|               +---group
|               |       group.component.css
|               |       group.component.html
|               |       group.component.spec.ts
|               |       group.component.ts
|               |
|               +---vine
|               |       vine.component.css
|               |       vine.component.html
|               |       vine.component.spec.ts
|               |       vine.component.ts
|               |
|               \---vineyard
|                       vineyard.component.css
|                       vineyard.component.html
|                       vineyard.component.spec.ts
|                       vineyard.component.ts
|
+---assets
|   |   .gitkeep
|   |
|   \---images
|           logo.png
|
\---openapi
        openapi.json